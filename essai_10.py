# -*- coding: utf-8 -*-
"""essai -10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XGnLV3G9kyz8iIxHxjVyGYFlmIaYoCbg
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler
from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense
from tensorflow.python.keras.wrappers.scikit_learn import KerasRegressor

from sklearn.preprocessing import RobustScaler


from math import *

! git clone --recursive https://github.com/pierreetienne-pion/data.git

df1 = pd.read_csv("/content/data/bdd_148nucleons.csv",  sep=';')
df=pd.read_csv("/content/data/bdd_159nucleons.csv")
df.head(10)

df1['sigma'] = df1['f1']*df1['E']*3*10*(pi*197.3269805)**2
df['sigma'] = df['f1']*df['E']*3*10*(pi*197.3269805)**2
df1.head()

dataset = df1.values
x=dataset[:,0:4]
y=dataset[:,6]
print(x)

y=np.reshape(y, (-1,1))
scaler_x = StandardScaler()
scaler_y = StandardScaler()
print(scaler_x.fit(x))
xscale=scaler_x.transform(x)
print(scaler_y.fit(y))
yscale=scaler_y.transform(y)

X_train=scaler_x.transform(x)
y_train=scaler_y.transform(y)

print(X_train)

import numpy as np
from sklearn import datasets, linear_model
from sklearn.model_selection import cross_val_score, KFold
from keras.models import Sequential
from sklearn.metrics import accuracy_score
from keras.layers import Dense
from keras.wrappers.scikit_learn import KerasRegressor

X=[]
for i in range(len(df[(df.Z == 6) & (df.A == 12)])):
    L=[]
    L.append(df.loc[(df['A']==12) & (df['Z']==6),:]['Z'].iloc[i])
    L.append(df.loc[(df['A']==12) & (df['Z']==6),:]['A'].iloc[i])
    L.append(df.loc[(df['A']==12) & (df['Z']==6),:]['E'].iloc[i])
    L.append(df.loc[(df['A']==12) & (df['Z']==6),:]['dE'].iloc[i])
    X.append(L)
Xnew=np.array(X)



model = Sequential()
model.add(Dense(100, input_dim=4, kernel_initializer='normal', activation='relu'))
model.add(Dense(90, activation='relu'))
model.add(Dense(75, activation='relu'))
model.add(Dense(50, activation='relu'))
model.add(Dense(25, activation='relu'))
model.add(Dense(10, activation='relu'))
model.add(Dense(1, activation='linear'))  
model.compile(loss='mean_squared_error', optimizer='adam')
model.summary()



history=model.fit(X_train, y_train, epochs=690, batch_size=72,  verbose=0, validation_split=0.01)

Xnew= scaler_x.transform(Xnew)
ynew= model.predict(Xnew)
ynew = scaler_y.inverse_transform(ynew) 
Xnew = scaler_x.inverse_transform(Xnew)

plt.plot(df[(df.Z == 6) & (df.A == 12)].E, df[(df.Z == 6) & (df.A == 12)].sigma)
plt.plot(df[(df.Z == 6) & (df.A == 12)].E, ynew)
plt.title('Z=6, A=12')
plt.ylabel('Sigma')
plt.xlabel('E')
plt.legend(['Expé', 'Prédiction'], loc='upper left')

plt.show()

"""ESSAI SUR LES NOYAUX NON-PRÉSENTS DANS LA BASE DE DONNÉE"""

liste=[(4,9),(8,17),(20,44),(32,74),(40,94),(42,97),(50,118),(50,112),(55,133),(76,188),(78,196)]

def graph(Zbarre,Abarre):
    sigma=[]
    E=[]
    for j in range(len(df.loc[(df['Z']==Zbarre) & (df['A']==Abarre),:]['sigma'])):
        sigma.append(df.loc[(df['Z']==Zbarre) & (df['A']==Abarre),:]['sigma'].iloc[j])
        E.append(df.loc[(df['Z']==Zbarre) & (df['A']==Abarre),:]['E'].iloc[j])
    plt.plot(E,sigma, color="blue", linewidth=1, linestyle="-")
    a=(Zbarre,Abarre)
    plt.title(a)

def predictionsurbaseid(Z,A):
    X=[]
    abcisses=[]
    for i in range(101):
      L=[]
      L.append(Z)
      L.append(A)
      L.append(5+i*0.2)
      L.append(0)
      X.append(L)
      abcisses.append(5+i*0.2)
    Xnewa=np.array(X)
    Xnewa= scaler_x.transform(Xnewa)
    ynewa= model.predict(Xnewa)
    ynewfi = scaler_y.inverse_transform(ynewa) 
    Xnewfi = scaler_x.inverse_transform(Xnewa)
    return(abcisses,ynewfi)



j=0
plt.figure(1, figsize=(15,15))
for i in liste:
  j=j+1
  graph(i[0],i[1])
  plt.plot(predictionsurbaseid(i[0],i[1])[0],predictionsurbaseid(i[0],i[1])[1],c='red')
  plt.subplot(4,4,j)

noy50 = pd.read_csv("/content/data/Z=50QRPA.csv", sep=';')

noy50.head(10)

noy50['sigma_000'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_002'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_005'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_008'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_010'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_020'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_030'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_050'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_070'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2
noy50['sigma_100'] = noy50['U=000MeV']*noy50['E[MeV]']*3*10*(pi*197.3269805)**2

noy50.head(10)

def quelU(U):
  if U==0 or U==00 or U==000:
    return('sigma_000')
  if U==2:
    return('sigma_002')
  if U==5:
    return('sigma_005')
  if U==8:
    return('sigma_008')
  if U==10:
    return('sigma_010')
  if U==20:
    return('sigma_020')
  if U==30:
    return('sigma_030')
  if U==50:
    return('sigma_050')
  if U==70:
    return('sigma_070')
  if U==100:
    return('sigma_100')


def traçageisotope(U):
  plt.figure(1, figsize=(15,15))
  L=[112,114,116,117,118,119,120,122,124]
  f1=quelU(U)
  for i in range(9):
    A=L[i]
    plt.plot(noy50.loc[(noy50['Z']==50) & (noy50['A']==A),:]['E[MeV]'],noy50.loc[(noy50['Z']==50) & (noy50['A']==A),:][f1])
  plt.show()

print(traçageisotope(50))

Xprime=[]
liste=df["Z"]
for i in range(len(liste)):
    Xprime.append(liste[i])

Xprimeprime=[]
liste2=df["A"]
for i in range(len(liste)):
    Xprimeprime.append(liste2[i])

X=[]
for i in range(len(liste)):
    X.append((liste[i],liste2[i]))


Z=[]
Ztext=[]


Xessai=X
while len(Xessai)>=32:
    a=Xessai[0]
    Z.append(a)
    i=0
    while Xessai[i]==a:
        i=i+1
    del Xessai[0:i]

Z.append((94,239))

M=[]
for i in range(17):
  M.append((50,124+2*i))


def traçageisotopeneuro(Ubs):
  plt.figure(1, figsize=(15,15))
  L=[]
  U=float(Ubs)
  for i in range(len(Z)):
    if Z[i][0]==U:
      L.append(Z[i])
  L=sorted(L)
  for i in range(17):
    L.append((50,124+2*i))
  print(L)
  for j in range(len(L)):
    A=L[j]
    X=predictionsurbaseid(L[j][0],L[j][1])[0]
    Y=predictionsurbaseid(L[j][0],L[j][1])[1]
    plt.plot(X,Y)
  plt.xlabel('E en MeV')
  plt.ylabel('Sigma en mb')
  plt.title(Ubs)

traçageisotopeneuro(50)
plt.text(13, 50, 'A=112', horizontalalignment = 'center', verticalalignment = 'center')
plt.text(13, 280, 'A=156', horizontalalignment = 'center', verticalalignment = 'center')

liste=[(4,9),(8,17),(20,44),(32,74),(40,94),(42,97),(50,118),(50,112),(55,133),(76,188),(78,196)]

y_pred= model.predict(liste)
y_predinv = scaler_y.inverse_transform(y_pred) 
y_testinv = scaler_y.inverse_transform(y_test)

plt.scatter(y_testinv, y_predinv,s=1)

x = np.linspace(0,1000)

plt.title('Répartition des prédictions par rapport à la valeur exactes (f(x)=x)')
plt.plot(x,x,'g',linewidth=2.5)